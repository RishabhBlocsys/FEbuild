{"version":3,"sources":["services/backend.service.js","services/web3.service.js","services/index.js","actions/auth.action.js","actions/user.action.js","actions/defi.action.js","actions/web3.action.js","actions/index.js","web3.js","contractData/contractAddress/addresses.js","config/index.js"],"names":["backendServices","get","post","put","url","params","a","token","localStorage","getItem","header","axios","headers","response","isAuthenticated","parameters","window","ethereum","request","method","getWeb3","isAuthenticate","web3","web3Data","isLoggedIn","accounts","eth","getAccounts","responseData","length","walletConnectModalInit","resp","code","send","error","msg","message","contractAbi","contractAddress","Contract","contractInstance","web3Services","getNetworkId","enableMetamask","getContractInstance","enabledWalletConnect","services","authActions","fetchBanners","dispatch","then","promise","data","fetchedData","fetcInfo","fetcHallFrameInfo","fetchDashboardConfig","getCreators","status","pagination","getMoreCreators","getMarketPlaceNFT","getMoreMarketPlaceNFT","getCollections","getCollectionDetails","id","getMoreCollections","updateCollection","getTopNFT","getTopCollection","getProfileInfo","getHallOfFrameArtist","getHallOfFrameArtwork","getHallOfFrameCollector","type","userActions","fetchCategories","getProfile","userId","getUserNFT","filter","updateUserDetails","createCollection","JSON","stringify","getUserDraftNFT","getSingleNFTDetails","getLikesCount","likeToggler","getIsLiked","getIsFollow","followToggler","getLikedNFT","getCollectedNFT","getCollectionNFT","getEditionHistory","nftId","edition","getNotifications","getProfileBanner","setLanguage","lng","sendInstagramCode","getTwitterAccessToken","verifyByTwitter","oauth_token","oauth_verifier","setData","defiActions","addNFT","authLogin","nonce","signature","setItem","newresp","details","generateNonce","address","getCategoryList","getCollectionList","getUserDetails","getUserProfile","updateNFT","setDispatchData","web3Actions","val","clear","getUserBalances","userAddress","getNFTContractInstance","nftContractAddress","contractAddresses","nftABI","actions","walletConnectProvider","WalletConnectProvider","rpc","chainId","qrcode","metamaskConnectInit","Promise","resolve","reject","Web3","currentProvider","providers","HttpProvider","enable","connector","on","err","payload","uri","WalletConnectQRCodeModal","open","close","reason","Number","connected","fetchNetworkId","getContractAddresses","escrowContractAddres","create","baseURL","expiryTime"],"mappings":"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","file":"static/js/5.1c2b1ba7.chunk.js","sourcesContent":["import axios from \"../config\";\r\nimport { web3 } from \"../web3\";\r\n// import userBalancesContract from \"../contracts/userBalances/userBalances\";\r\n// import tokens from \"../tokens.json\";\r\n// import { param } from \"jquery\";\r\n\r\nexport const backendServices = {\r\n  get,\r\n  post,\r\n  put,\r\n};\r\n\r\nasync function post(url, params) {\r\n  const token = localStorage.getItem(\"fibitAuthToken\");\r\n  const header = token\r\n    ? { \"content-type\": \"application/json\", \"x-auth-token\": token }\r\n    : {\r\n        \"content-type\": \"application/json\",\r\n      };\r\n  // console.log(\"this\", header);\r\n  try {\r\n    const response = await axios.post(url, params, { headers: header });\r\n    return response;\r\n  } catch (error) {\r\n    // console.log(\"new\", error.response);\r\n    return error;\r\n  }\r\n}\r\n\r\nasync function get(url, isAuthenticated) {\r\n  const token = localStorage.getItem(\"fibitAuthToken\");\r\n  const header = isAuthenticated\r\n    ? { \"x-auth-token\": token, \"content-type\": \"application/json\" }\r\n    : {\r\n        \"content-type\": \"application/json\",\r\n      };\r\n  try {\r\n    const response = await axios.get(url, { headers: header });\r\n    return response;\r\n  } catch (error) {\r\n    return error;\r\n  }\r\n}\r\n\r\nasync function put(url, parameters) {\r\n  const token = localStorage.getItem(\"fibitAuthToken\");\r\n  const header = token\r\n    ? { \"x-auth-token\": token }\r\n    : {\r\n        \"content-type\": \"application/json\",\r\n      };\r\n  try {\r\n    const response = await axios.put(url, parameters, { headers: header });\r\n    return response;\r\n  } catch (error) {\r\n    return error;\r\n  }\r\n}\r\n\r\nlet web3Data = {\r\n  isLoggedIn: false,\r\n  accounts: [],\r\n};\r\n\r\n// async function getWeb3(val) {\r\n//   if (web3) {\r\n//     try {\r\n//       let web3Data = {\r\n//         isLoggedIn: false,\r\n//         accounts: [],\r\n//       };\r\n//       const responseData = await web3.eth.getAccounts();\r\n\r\n//       if (responseData.length) {\r\n//         web3Data.isLoggedIn = true;\r\n//         web3Data.accounts = responseData;\r\n//         return web3Data;\r\n//       } else {\r\n//         return web3Data;\r\n//       }\r\n//     } catch {\r\n//       return web3Data;\r\n//     }\r\n//   }\r\n// }\r\n","import { web3, walletConnectModalInit } from \"../web3\";\r\n\r\nasync function getNetworkId() {\r\n  try {\r\n    return await window.ethereum.request({ method: \"eth_chainId\" });\r\n  } catch (error) {\r\n    return 1;\r\n  }\r\n}\r\nasync function getWeb3(isAuthenticate) {\r\n  if (web3) {\r\n    let web3Data = {\r\n      isLoggedIn: false,\r\n      accounts: [],\r\n    };\r\n    try {\r\n      const responseData = await web3.eth.getAccounts();\r\n\r\n      if (responseData.length) {\r\n        web3Data.accounts = responseData;\r\n        if (isAuthenticate) {\r\n          web3Data.isLoggedIn = true;\r\n        }\r\n        return web3Data;\r\n      } else {\r\n        return web3Data;\r\n      }\r\n    } catch {\r\n      return web3Data;\r\n    }\r\n  }\r\n}\r\n\r\nasync function enabledWalletConnect() {\r\n  try {\r\n    await walletConnectModalInit();\r\n    const resp = await getWeb3();\r\n    return resp;\r\n  } catch (error) {\r\n    if (error.code === -32002) {\r\n      return {\r\n        isLoggedIn: false,\r\n        accounts: [],\r\n      };\r\n    }\r\n    return {\r\n      isLoggedIn: false,\r\n      accounts: [],\r\n    };\r\n  }\r\n}\r\nasync function enableMetamask() {\r\n  try {\r\n    await window.ethereum.send(\"eth_requestAccounts\");\r\n    const resp = await getWeb3();\r\n    return resp;\r\n  } catch (error) {\r\n    if (error.code === -32002) {\r\n      return {\r\n        error: true,\r\n        code: error.code,\r\n        msg: error.message,\r\n        isLoggedIn: false,\r\n        accounts: [],\r\n      };\r\n    }\r\n    if (error.code === 4001) {\r\n      return {\r\n        error: true,\r\n        code: error.code,\r\n        msg: error.message,\r\n        isLoggedIn: false,\r\n        accounts: [],\r\n      };\r\n    }\r\n    return {\r\n      error: true,\r\n      code: error.code,\r\n      msg: error.message,\r\n      isLoggedIn: false,\r\n      accounts: [],\r\n    };\r\n  }\r\n}\r\n\r\nasync function getContractInstance(contractAbi, contractAddress) {\r\n  try {\r\n    if (web3) {\r\n      const contractInstance = await new web3.eth.Contract(\r\n        contractAbi,\r\n        contractAddress\r\n      );\r\n      return contractInstance;\r\n    }\r\n  } catch (error) {\r\n    // console.log(error);\r\n  }\r\n}\r\n\r\nexport const web3Services = {\r\n  getNetworkId,\r\n  enableMetamask,\r\n  getContractInstance,\r\n  getWeb3,\r\n  enabledWalletConnect,\r\n};\r\n","import { backendServices } from './backend.service';\r\nimport { web3Services } from './web3.service';\r\n\r\nexport const services = { ...backendServices, ...web3Services };\r\n","import { services } from \"../services\";\r\n\r\nexport const authActions = {\r\n  fetchBanners,\r\n  fetcInfo,\r\n  fetcHallFrameInfo,\r\n  fetchDashboardConfig,\r\n  getCreators,\r\n  getMoreCreators,\r\n  getMarketPlaceNFT,\r\n  getMoreMarketPlaceNFT,\r\n  getCollections,\r\n  getCollectionDetails,\r\n  getMoreCollections,\r\n  updateCollection,\r\n  getTopNFT,\r\n  getTopCollection,\r\n  getProfileInfo,\r\n  getHallOfFrameArtist,\r\n  getHallOfFrameArtwork,\r\n  getHallOfFrameCollector,\r\n};\r\n\r\nfunction fetchedData(type, data) {\r\n  return {\r\n    type: type,\r\n    data: data,\r\n  };\r\n}\r\n\r\nfunction fetchBanners() {\r\n  return (dispatch) => {\r\n    const response = services.get(`/admin/banner/list`);\r\n    return response.then((promise) => {\r\n      if (promise.data) {\r\n        dispatch(fetchedData(\"FETCHED_NFT_BANNERS\", promise.data.data));\r\n      } else {\r\n        // console.log('error in getBanners actions');\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction fetcInfo() {\r\n  return (dispatch) => {\r\n    const response = services.get(`/admin/info/list`);\r\n    return response.then((promise) => {\r\n      if (promise.data) {\r\n        dispatch(fetchedData(\"FETCHED_INFO\", promise.data.data));\r\n      } else {\r\n        // console.log('error in fetcInfo actions');\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction fetcHallFrameInfo() {\r\n  return (dispatch) => {\r\n    const response = services.get(`/admin/hall-frame-info/list`);\r\n    return response.then((promise) => {\r\n      if (promise.data) {\r\n        dispatch(fetchedData('FETCHED_HALL_FRAME_INFO', promise.data.data));\r\n      } else {\r\n        // console.log('error in fetcHallFrameInfo actions');\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction fetchDashboardConfig() {\r\n  return (dispatch) => {\r\n    const response = services.get(`/admin/dashboard/list`);\r\n    return response.then((promise) => {\r\n      if (promise.data) {\r\n        dispatch(fetchedData(\"FETCHED_DASHBOARD\", promise.data.data));\r\n      } else {\r\n        // console.log('error in fetchDashboardConfig actions');\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction getCreators(params={}) {\r\n  return async (dispatch) => {\r\n    const response = services.post(`user/listVerifiefCreator`, params);\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(fetchedData(\"FETCHED_PAGINATION\", promise.data.pagination));\r\n        dispatch(fetchedData(\"FETCHED_CREATORS\", promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction getMoreCreators(params={}) {\r\n  return async (dispatch) => {\r\n    const response = services.post(`user/listVerifiefCreator`, params);\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(fetchedData(\"FETCHED_PAGINATION\", promise.data.pagination));\r\n        dispatch(fetchedData(\"FETCHED_MORE_CREATORS\", promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction getMarketPlaceNFT(params={}) {\r\n  return async (dispatch) => {\r\n    const response = services.post(`nft/listMarketPlace`, params);\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(fetchedData(\"FETCHED_PAGINATION\", promise.data.pagination));\r\n        dispatch(fetchedData(\"FETCHED_MARKETPLACE\", promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction getMoreMarketPlaceNFT(params={}) {\r\n  return async (dispatch) => {\r\n    const response = services.post(`nft/listMarketPlace`, params);\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(fetchedData(\"FETCHED_PAGINATION\", promise.data.pagination));\r\n        dispatch(fetchedData(\"FETCHED_MORE_MARKETPLACE\", promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction getCollections(params={}) {\r\n  return async (dispatch) => {\r\n    const response = services.post(`nft/listCollections`, params);\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(fetchedData(\"FETCHED_PAGINATION\", promise.data.pagination));\r\n        dispatch(fetchedData(\"FETCHED_COLLECTIONS\", promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction getMoreCollections(params={}) {\r\n  return async (dispatch) => {\r\n    const response = services.post(`nft/listCollections`, params);\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(fetchedData(\"FETCHED_PAGINATION\", promise.data.pagination));\r\n        dispatch(fetchedData(\"FETCHED_MORE_COLLECTIONS\", promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction getCollectionDetails(params={}) {\r\n  return async (dispatch) => {\r\n    const response = services.get(`nft/getCollectionInfo/${params.id}`, true);\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(fetchedData(\"FETCHED_COLLECTION_DETAIL\", promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction updateCollection(params = {}) {\r\n  return async (dispatch) => {\r\n    const response = services.put(`nft/updateCollection/${params.id}`, params);\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(fetchedData(\"COLLECTION_UPDATED\", promise.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction getTopNFT() {\r\n  return (dispatch) => {\r\n    const response = services.get(`/admin/popular/list`, true);\r\n    return response.then((promise) => {\r\n      if (promise.data) {\r\n        dispatch(fetchedData(\"FETCHED_TOP_NFT\", promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction getTopCollection() {\r\n  return (dispatch) => {\r\n    const response = services.get(`/admin/popularCollection/list`, true);\r\n    return response.then((promise) => {\r\n      if (promise.data) {\r\n        dispatch(fetchedData(\"FETCHED_TOP_COLLECTION\", promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction getProfileInfo() {\r\n  return (dispatch) => {\r\n    const response = services.get(`/admin/profile-info/list`);\r\n    return response.then((promise) => {\r\n      if (promise.data) {\r\n        dispatch(fetchedData(\"FETCHED_PROFILE_INFO\", promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction getHallOfFrameArtist() {\r\n  return (dispatch) => {\r\n    const response = services.get(`/hallOfFrame/list/artist`);\r\n    return response.then((promise) => {\r\n      if (promise.data) {\r\n        dispatch(fetchedData(\"FETCHED_HALL_OF_FRAMES_ARTIST\", promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction getHallOfFrameArtwork() {\r\n  return (dispatch) => {\r\n    const response = services.get(`/hallOfFrame/list/artwork`);\r\n    return response.then((promise) => {\r\n      if (promise.data) {\r\n        dispatch(fetchedData(\"FETCHED_HALL_OF_FRAMES_ARTWORK\", promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction getHallOfFrameCollector() {\r\n  return (dispatch) => {\r\n    const response = services.get(`/hallOfFrame/list/collector`);\r\n    return response.then((promise) => {\r\n      if (promise.data) {\r\n        dispatch(fetchedData(\"FETCHED_HALL_OF_FRAMES_COLLECTOR\", promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}","import { services } from '../services';\r\n\r\nexport const userActions = {\r\n  fetchCategories,\r\n  getProfile,\r\n  getUserNFT,\r\n  getCreators,\r\n  updateUserDetails,\r\n  getMoreCreators,\r\n  createCollection,\r\n  getUserDraftNFT,\r\n  getSingleNFTDetails,\r\n  getLikesCount,\r\n  likeToggler,\r\n  getIsLiked,\r\n  getIsFollow,\r\n  followToggler,\r\n  getLikedNFT,\r\n  getCollectedNFT,\r\n  getCollectionNFT,\r\n  getEditionHistory,\r\n  getNotifications,\r\n  getProfileBanner,\r\n  setLanguage,\r\n  sendInstagramCode,\r\n  getTwitterAccessToken,\r\n  verifyByTwitter,\r\n};\r\n\r\nfunction fetchedData(type, data) {\r\n  return {\r\n    type: type,\r\n    data: data,\r\n  };\r\n}\r\n\r\nfunction fetchCategories() {\r\n  return async (dispatch) => {\r\n    const response = services.get(`/category/list`);\r\n    const promise = await response;\r\n    if (promise.data) {\r\n      dispatch(fetchedData('FETCHED_CATEGORIES', promise.data.data));\r\n    } else {\r\n      // console.log('error in fetchCategories actions');\r\n    }\r\n  };\r\n}\r\n\r\nfunction getProfile(userId) {\r\n  return (dispatch) => {\r\n    const response = services.get(`user/userDetails?userId=${userId}`, true);\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(fetchedData('FETCHED_PROFILE', promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction updateUserDetails(params) {\r\n  return async (dispatch) => {\r\n    try {\r\n      const response = services.put(`user/update`, params);\r\n      response.then((promise) => {\r\n        if (promise.status === 200) {\r\n          dispatch(fetchedData('PROFILE_UPDATED', promise.data.data));\r\n        } else {\r\n          // console.log(\"error\");\r\n        }\r\n      });\r\n      response.then((data) => {\r\n        if (data.response) {\r\n          dispatch(fetchedData('API_FAILED', data.response.data.message));\r\n        }\r\n      });\r\n    } catch (error) {\r\n      // console.log(\"error\");\r\n    }\r\n  };\r\n}\r\n\r\nfunction getUserNFT(id, filter) {\r\n  return async (dispatch) => {\r\n    const response = services.get(\r\n      id\r\n        ? `nft/listNftByUser/${id}?status=${filter}`\r\n        : `nft/listNftByUser?status=${filter}`,\r\n      true\r\n    );\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(fetchedData('FETCHED_USER_NFT', promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\nfunction createCollection(data) {\r\n  let params = JSON.stringify(data);\r\n  return async (dispatch) => {\r\n    const response = services.post('nft/addCollection', params);\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(fetchedData('CREATE_COLLECTION', promise.data));\r\n      } else {\r\n        dispatch(fetchedData('CREATE_COLLECTION', promise.response.data));\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction getCreators(params = {}) {\r\n  return async (dispatch) => {\r\n    const response = services.post(`user/listVerifiefCreator`, params);\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(fetchedData('FETCHED_PAGINATION', promise.data.pagination));\r\n        dispatch(fetchedData('FETCHED_CREATORS', promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction getMoreCreators(params = {}) {\r\n  return async (dispatch) => {\r\n    const response = services.post(`user/listVerifiefCreator`, params);\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(fetchedData('FETCHED_PAGINATION', promise.data.pagination));\r\n        dispatch(fetchedData('FETCHED_MORE_CREATORS', promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction getUserDraftNFT() {\r\n  return async (dispatch) => {\r\n    const response = services.get(`nft/listNftByUser?filter=draft`, true);\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(fetchedData('FETCHED_USER_DRAFT_NFT', promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nasync function getSingleNFTDetails(id) {\r\n  // console.log('called', id);\r\n  // return async (dispatch) => {\r\n  const response = await services.get(`nft/single/${id}`, true);\r\n  // console.log(\"called\",response)\r\n\r\n  // return promise.data.data;\r\n  // response.then((promise) => {\r\n  if (response.status === 200) {\r\n    // console.log(\"called\",response.data.data)\r\n    return response.data.data;\r\n  } else {\r\n    // console.log(\"called\",response)\r\n    return null;\r\n    // console.log(\"error\");\r\n  }\r\n  // });\r\n}\r\n// }\r\n\r\nfunction getLikesCount(id) {\r\n  return async (dispatch) => {\r\n    const response = services.get(`like/getLikesCount/${id}`);\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(fetchedData('FETCHED_LIKES_COUNT', promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\nfunction likeToggler(id) {\r\n  return async (dispatch) => {\r\n    const response = services.get(`like/toggle/${id}`, true);\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(getIsLiked(id));\r\n        dispatch(getLikesCount(id));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction getIsLiked(id) {\r\n  return async (dispatch) => {\r\n    const response = services.get(`like/isLiked/${id}`, true);\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(fetchedData('FETCHED_IS_LIKED', promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction getIsFollow(id) {\r\n  return async (dispatch) => {\r\n    const response = services.get(`follow/checkIsFollowed/${id}`, true);\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(fetchedData('FETCHED_IS_FOLLOW', promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction followToggler(id) {\r\n  return async (dispatch) => {\r\n    const response = services.get(`follow/toggle/${id}`, true);\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(getIsFollow(id));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction getLikedNFT(id) {\r\n  return async (dispatch) => {\r\n    const response = services.get(\r\n      id ? `nft/getLikedNfts/${id}` : `nft/getLikedNfts`,\r\n      true\r\n    );\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(fetchedData('FETCHED_LIKED_NFT', promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction getCollectedNFT(id) {\r\n  return async (dispatch) => {\r\n    const response = services.get(\r\n      id ? `nft/getCollectedNfts/${id}` : `nft/getCollectedNfts`,\r\n      true\r\n    );\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(fetchedData('FETCHED_COLLECTED_NFT', promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction getCollectionNFT(id) {\r\n  return async (dispatch) => {\r\n    const response = services.get(\r\n      id ? `nft/listCollection/${id}` : `nft/listCollection`,\r\n      true\r\n    );\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(fetchedData('FETCHED_COLLECTION_NFT', promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction getEditionHistory(nftId, edition) {\r\n  return async (dispatch) => {\r\n    const response = services.get(`nft/history/${nftId}/${edition}`);\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(fetchedData('FETCHED_NFT_EDITION_HISTORY', promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction getNotifications() {\r\n  return async (dispatch) => {\r\n    const response = services.get(`notification/list`, true);\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(fetchedData('FETCHED_NOTIFICATIONS', promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction getProfileBanner() {\r\n  return (dispatch) => {\r\n    const response = services.get(`/admin/profile-info/list`);\r\n    return response.then((promise) => {\r\n      if (promise.data) {\r\n        dispatch(fetchedData('FETCHED_PROFILE_BANNERS', promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction setLanguage(lng) {\r\n  return (dispatch) => {\r\n    // const response = services.get(`/admin/profile-info/list`);\r\n    // return response.then((promise) => {\r\n    //   if (promise.data) {\r\n    dispatch(fetchedData('SET_LANGUAGE', lng));\r\n    // } else {\r\n    //   // console.log(\"error\");\r\n    // }\r\n    // });\r\n  };\r\n}\r\nfunction sendInstagramCode(code) {\r\n  return (dispatch) => {\r\n    const response = services.post(`/user/validateInstagram`, { code: code });\r\n    return response.then((promise) => {\r\n      if (promise.data) {\r\n        dispatch(fetchedData('VERIFIED_BY_INSTAGRAM', promise.status));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\nfunction getTwitterAccessToken() {\r\n  return (dispatch) => {\r\n    const response = services.get(`/user/twitter/access_token`, true);\r\n    return response.then((promise) => {\r\n      if (promise.data) {\r\n        dispatch(fetchedData('TWITTER_ACCESS_TOKEN', promise.data.data));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\nfunction verifyByTwitter(oauth_token, oauth_verifier) {\r\n  return (dispatch) => {\r\n    const response = services.post(`/user/validateTwitter`, {\r\n      oauth_verifier: oauth_verifier,\r\n      oauth_token: oauth_token,\r\n    });\r\n    return response.then((promise) => {\r\n      if (promise.data) {\r\n        dispatch(fetchedData('VERIFIED_BY_TWITTER', promise.status));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n","import { services } from \"../services\";\r\n\r\nfunction setData(data, type) {\r\n  return {\r\n    type: type,\r\n    data: data,\r\n  };\r\n}\r\n\r\nfunction addNFT(data) {\r\n  return (dispatch) => {\r\n    const url = \"nft/addNft\";\r\n    let params = JSON.stringify(data);\r\n    const response = services.post(url, params);\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(setData(promise.data.data, \"ADD_NFT\"));\r\n      } else {\r\n        // console.log('erroer');\r\n      }\r\n    });\r\n  };\r\n}\r\nfunction authLogin(nonce, signature) {\r\n  return (dispatch) => {\r\n    const url = \"user/login\";\r\n    let params = JSON.stringify({\r\n      nonce: nonce,\r\n      signature: signature,\r\n    });\r\n    const response = services.post(url, params);\r\n    response.then(async (promise) => {\r\n      if (promise.status === 200) {\r\n        localStorage.setItem(\"fibitAuthToken\", promise.data.data.token);\r\n        if (promise.data.data.token) {\r\n          const newresp = await services.getWeb3();\r\n          localStorage.setItem(\"userAddress\", newresp.accounts[0]);\r\n          newresp.isLoggedIn = true;\r\n          dispatch(setData(newresp, \"FETCH_WEB3_DATA\"));\r\n        }\r\n        dispatch(\r\n          setData(\r\n            { data: promise.data.data.details, status: true },\r\n            \"AUTH_LOGIN\"\r\n          )\r\n        );\r\n      } else {\r\n        localStorage.setItem(\"fibitAuthToken\", \"\");\r\n      }\r\n    });\r\n  };\r\n}\r\nfunction generateNonce(address) {\r\n  return async (dispatch) => {\r\n    const url = `user/genrateNonce/${address}`;\r\n    const response = services.get(url);\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(setData(promise.data.data.nonce, \"GENERATE_NONCE\"));\r\n      } else {\r\n        // console.log(\"erroer\");\r\n      }\r\n    });\r\n  };\r\n}\r\nfunction getCategoryList() {\r\n  return async (dispatch) => {\r\n    const url = `category/list`;\r\n    const response = services.get(url);\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(setData(promise.data.data, \"CATEGORY_LIST\"));\r\n      } else {\r\n        // console.log(\"erroer\");\r\n      }\r\n    });\r\n  };\r\n}\r\nfunction getCollectionList() {\r\n  return async (dispatch) => {\r\n    const url = `nft/listCollection`;\r\n    const response = services.get(url, true);\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(setData(promise.data.data, \"COLLECTION_LIST\"));\r\n      } else {\r\n        // console.log(\"erroer\");\r\n      }\r\n    });\r\n  };\r\n}\r\n// function authenticateUser() {\r\n//   return (dispatch) => {\r\n//     const response = services.getWeb3(true);\r\n//     response.then((promise) => {\r\n//       if (promise.accounts[0]) {\r\n//         dispatch(setDispatchData(promise, \"FETCH_WEB3_DATA\"));\r\n//       } else {\r\n//         // console.log('errorrrr in actions');\r\n//       }\r\n//     });\r\n//   };\r\n// }\r\nfunction getUserDetails() {\r\n  return (dispatch) => {\r\n    const response = services.get(\"user/userDetails\", true);\r\n    response.then(async (promise) => {\r\n      if (promise.status === 200) {\r\n        if (promise.data.data) {\r\n          const newresp = await services.getWeb3();\r\n          localStorage.setItem(\"userAddress\", newresp.accounts[0]);\r\n          newresp.isLoggedIn = true;\r\n          dispatch(setData(newresp, \"FETCH_WEB3_DATA\"));\r\n        }\r\n        dispatch(setData(promise.data, \"AUTH_LOGIN\"));\r\n      } else {\r\n        localStorage.setItem(\"fibitAuthToken\", \"\");\r\n        if (!promise.response && promise.response?.status === 401) {\r\n          dispatch(setData(promise.response, \"AUTH_LOGIN_ERROR\"));\r\n        }\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction getUserProfile(id) {\r\n  return async (dispatch) => {\r\n    const response = services.get(`user/getSingleUser/${id}`);\r\n    response.then((promise) => {\r\n      if (promise.status === 200) {\r\n        dispatch(setData(promise.data.data, \"FETCHED_USER_PROFILE\"));\r\n      } else {\r\n        // console.log(\"error\");\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction updateNFT(data) {\r\n  return (dispatch) => {\r\n    const url = `nft/updateNft/${data.id}`;\r\n    const response = services.put(url, data).then((response) => {\r\n      if (response.status === 200) {\r\n        dispatch(setData(response.data, \"UPDATE_NFT\"));\r\n      }\r\n      if (response.response && response.response.status === 403) {\r\n        dispatch(setData(response.response.data, \"UPDATE_NFT\"));\r\n      }\r\n      if (response.response && response.response.status === 400) {\r\n        dispatch(setData(response.response.data, \"UPDATE_NFT\"));\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nexport const defiActions = {\r\n  addNFT,\r\n  authLogin,\r\n  generateNonce,\r\n  getCategoryList,\r\n  getCollectionList,\r\n  getUserDetails,\r\n  getUserProfile,\r\n  updateNFT,\r\n};\r\n","import { services } from '../services';\r\nimport nftABI from '../contractData/abis/nft.json';\r\nimport contractAddresses from '../contractData/contractAddress/addresses';\r\n\r\nfunction fetchUserBalances(data) {\r\n  return {\r\n    type: 'FETCH_USER_BALANCES', // dispatch user login event\r\n    data: data,\r\n  };\r\n}\r\n\r\nfunction setDispatchData(data, type) {\r\n  return { data: data, type: type };\r\n}\r\n\r\n// get defi categories\r\nfunction getNetworkId() {\r\n  return (dispatch) => {\r\n    const response = services.getNetworkId();\r\n    response.then((promise) => {\r\n      dispatch(setDispatchData(promise, 'FETCH_NETWORK_ID'));\r\n    });\r\n  };\r\n}\r\n\r\nfunction getWeb3(val) {\r\n  if (val) {\r\n    return (dispatch) => {\r\n      dispatch(setDispatchData(null, 'FETCH_WEB3_DATA'));\r\n    };\r\n  } else\r\n    return (dispatch) => {\r\n      const response = services.getWeb3();\r\n      response.then((promise) => {\r\n        if (promise?.accounts[0]) {\r\n          dispatch(setDispatchData(promise, 'FETCH_WEB3_DATA'));\r\n        } else {\r\n          localStorage.clear();\r\n          // console.log('errorrrr in actions');\r\n        }\r\n      });\r\n    };\r\n}\r\n\r\nfunction enabledWalletConnect() {\r\n  return (dispatch) => {\r\n    const response = services.enabledWalletConnect();\r\n    response.then((promise) => {\r\n      if (promise) {\r\n        dispatch(setDispatchData(promise, 'FETCH_WEB3_DATA'));\r\n      } else {\r\n        // console.log('error in actions');\r\n      }\r\n    });\r\n  };\r\n}\r\nfunction enableMetamask() {\r\n  return (dispatch) => {\r\n    const response = services.enableMetamask();\r\n    response.then((promise) => {\r\n      // console.log(\"present\");\r\n      if (!promise.error) {\r\n        // console.log(\"this is new actions\", promise);\r\n        dispatch(setDispatchData(promise, 'FETCH_WEB3_DATA'));\r\n      } else {\r\n        // console.log(\"i am in error\", promise);\r\n        dispatch(setDispatchData(promise, 'FETCH_WEB3_DATA_ERROR'));\r\n      }\r\n    });\r\n  };\r\n}\r\nfunction getUserBalances(userAddress) {\r\n  return (dispatch) => {\r\n    const response = services.getUserBalances(userAddress);\r\n    response.then((promise) => {\r\n      if (promise) {\r\n        dispatch(fetchUserBalances(promise));\r\n      } else {\r\n        // console.log('error in actions');\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction getNFTContractInstance() {\r\n  const { nftContractAddress } = contractAddresses();\r\n  return (dispatch) => {\r\n    const response = services.getContractInstance(nftABI, nftContractAddress);\r\n    response.then((promise) => {\r\n      // console.log(promise);\r\n      if (promise) {\r\n        dispatch(setDispatchData(promise, 'NFT_CONTRACT_INSTANCE'));\r\n      } else {\r\n        // console.log('error in actions');\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nexport const web3Actions = {\r\n  getNetworkId,\r\n  getWeb3,\r\n  enableMetamask,\r\n  getUserBalances,\r\n  getNFTContractInstance,\r\n  enabledWalletConnect,\r\n};\r\n","import { authActions } from \"./auth.action\";\r\nimport { userActions } from \"./user.action\";\r\nimport { defiActions } from \"./defi.action\";\r\nimport { web3Actions } from \"./web3.action\";\r\n\r\n\r\nexport const actions = {\r\n    ...authActions,\r\n    ...defiActions,\r\n    ...web3Actions,\r\n    ...userActions,\r\n};","import WalletConnectProvider from '@walletconnect/web3-provider';\r\nimport Web3 from 'web3';\r\nimport WalletConnectQRCodeModal from '@walletconnect/qrcode-modal';\r\n\r\nlet web3 = null;\r\nlet walletConnectProvider = new WalletConnectProvider({\r\n  rpc: {\r\n    0x38: 'https://speedy-nodes-nyc.moralis.io/5be1af5bcc43ff8e4432ee14/bsc/mainnet/archive', // BSC Mainnet chainId - 56\r\n    // 0x61: 'https://data-seed-prebsc-1-s1.binance.org:8545/', // BSC Testnet chainId - 97\r\n  },\r\n  chainId: 56, // BSC Mainnet\r\n  // chainId: 0x61, // BSC Testnet\r\n  qrcode: false,\r\n});\r\n\r\nconst metamaskConnectInit = () => {\r\n  // Check if Web3 has been injected by the browser (Mist/MetaMask).\r\n  return new Promise((resolve, reject) => {\r\n    if (typeof window.web3 !== 'undefined') {\r\n      // Use Mist/MetaMask's provider.\r\n      web3 = new Web3(window.web3.currentProvider);\r\n      localStorage.setItem('walletConnect', 0);\r\n      resolve(true);\r\n    } else {\r\n      // Handle the case where the user doesn't have web3. Probably\r\n      // show them a message telling them to install Metamask in\r\n      // order to use the app.\r\n      web3 = new Web3(\r\n        new Web3.providers.HttpProvider(\r\n          'https://bsc-dataseed.binance.org/'\r\n          // \"https://data-seed-prebsc-1-s1.binance.org:8545/\"\r\n        )\r\n      );\r\n      reject(false);\r\n    }\r\n  });\r\n};\r\n\r\nconst walletConnectInit = () => {\r\n  // Check if WalleConnect has been conected by the website\r\n  return new Promise((resolve, reject) => {\r\n    if (!walletConnectProvider.connector.connected) {\r\n      metamaskConnectInit();\r\n      reject(false);\r\n    } else {\r\n      // Use WalletConnect provider.\r\n      walletConnectProvider.enable();\r\n      web3 = new Web3(walletConnectProvider);\r\n      resolve(true);\r\n    }\r\n  });\r\n};\r\n\r\nconst walletConnectModalInit = () => {\r\n  return new Promise((resolve, reject) => {\r\n    localStorage.setItem('walletConnect', 1);\r\n    walletConnectProvider.enable();\r\n    web3 = new Web3(walletConnectProvider);\r\n    // Wallet Connect Provider Events\r\n    walletConnectProvider.connector.on('display_uri', (err, payload) => {\r\n      const uri = payload.params[0];\r\n      WalletConnectQRCodeModal.open(uri);\r\n    });\r\n    walletConnectProvider.on('connect', () => {\r\n      WalletConnectQRCodeModal.close(); // close the QR scanner modal\r\n    });\r\n    walletConnectProvider.on('disconnect', (code, reason) => {\r\n      // console.log('wallet connect disconnected', code, reason);\r\n      localStorage.clear();\r\n    });\r\n    resolve(true);\r\n  });\r\n};\r\n\r\nif (!web3) {\r\n  if (Number(localStorage.getItem('walletConnect')) > 0) {\r\n    walletConnectInit();\r\n  } else metamaskConnectInit();\r\n}\r\n\r\nexport {\r\n  web3,\r\n  walletConnectProvider,\r\n  walletConnectInit,\r\n  metamaskConnectInit,\r\n  walletConnectModalInit,\r\n};\r\n","import { services } from \"../../services\";\r\nlet networkId = 1;\r\nasync function fetchNetworkId() {\r\n  networkId = await services.getNetworkId();\r\n}\r\nfetchNetworkId();\r\n\r\nfunction getContractAddresses() {\r\n  if (networkId === \"0x4\" || +networkId === 4)\r\n    return {\r\n      token: \"0x7862A31a1a1184882CEe3Aec91Bcc93B0512D09F\",\r\n      nftContractAddress: \"0x932a362d89b60FE93e5d84E009E2C956578Ab536\",\r\n      escrowContractAddres: \"0xf8faB097B5ecFAe11f5257F4fAfF9415bFe25514\",\r\n    };\r\n  else if (+networkId === 1 || networkId === \"0x1\")\r\n    return {\r\n      token: \"0x7862A31a1a1184882CEe3Aec91Bcc93B0512D09F\",\r\n      nftContractAddress: \"0x932a362d89b60FE93e5d84E009E2C956578Ab536\",\r\n      escrowContractAddres: \"0xf8faB097B5ecFAe11f5257F4fAfF9415bFe25514\",\r\n    };\r\n  else\r\n    return {\r\n      token: \"0x7862A31a1a1184882CEe3Aec91Bcc93B0512D09F\",\r\n      nftContractAddress: \"0x932a362d89b60FE93e5d84E009E2C956578Ab536\",\r\n      escrowContractAddres: \"0xf8faB097B5ecFAe11f5257F4fAfF9415bFe25514\",\r\n    };\r\n}\r\nexport default getContractAddresses;\r\n","import axios from \"axios\";\r\n// staging server\r\nexport default axios.create({\r\n  baseURL: \"http://api.3.67.57.47.nip.io/api/v1\",\r\n});\r\n\r\n// // Local\r\n// export const server_url = \"http://127.0.0.1:4000/\";\r\n\r\n// aws s3 bucket confiurations\r\nexport const awsRegion = \"eu-central-1\";\r\nexport const awsIdentityPoolId =\r\n  \"eu-central-1:949b9487-ed35-4eb3-a2d3-1866e6ad890b\";\r\nexport const awsBucket = \"avangrat-development\";\r\n\r\n// set expiry time for the localstorage/cookie data\r\nexport const expiryTime = 2; // 2 hours\r\n\r\n// Instragram config\r\nexport const client_id = \"4418122684888051\";\r\nexport const redirect_url = \"http://api.3.67.57.47.nip.io/user/edit-profile/\";\r\n"],"sourceRoot":""}