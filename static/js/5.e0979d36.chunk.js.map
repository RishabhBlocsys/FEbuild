{"version":3,"sources":["services/backend.service.js","services/web3.service.js","services/index.js","actions/auth.action.js","actions/user.action.js","actions/defi.action.js","actions/web3.action.js","actions/index.js","web3.js","contractData/contractAddress/addresses.js","config/index.js"],"names":["backendServices","get","post","put","url","params","a","token","localStorage","getItem","header","axios","headers","response","isAuthenticated","parameters","window","ethereum","request","method","getWeb3","isAuthenticate","web3","web3Data","isLoggedIn","accounts","eth","getAccounts","responseData","length","walletConnectModalInit","resp","code","send","error","msg","message","contractAbi","contractAddress","Contract","contractInstance","web3Services","getNetworkId","enableMetamask","getContractInstance","enabledWalletConnect","services","authActions","fetchBanners","dispatch","then","promise","data","fetchedData","fetcInfo","fetcHallFrameInfo","fetchDashboardConfig","getCreators","status","pagination","getMoreCreators","getMarketPlaceNFT","getMoreMarketPlaceNFT","getCollections","getCollectionDetails","id","getMoreCollections","updateCollection","getTopNFT","getTopCollection","getProfileInfo","getHallOfFrameArtist","getHallOfFrameArtwork","getHallOfFrameCollector","type","userActions","fetchCategories","getProfile","userId","getUserNFT","filter","updateUserDetails","createCollection","JSON","stringify","getUserDraftNFT","getSingleNFTDetails","getLikesCount","likeToggler","getIsLiked","getIsFollow","followToggler","getLikedNFT","getCollectedNFT","getCollectionNFT","getEditionHistory","nftId","edition","getNotifications","getProfileBanner","setLanguage","lng","sendInstagramCode","getTwitterAccessToken","verifyByTwitter","oauth_token","oauth_verifier","setData","defiActions","addNFT","authLogin","nonce","signature","setItem","newresp","details","generateNonce","address","getCategoryList","getCollectionList","getUserDetails","getUserProfile","updateNFT","setDispatchData","web3Actions","val","clear","getUserBalances","userAddress","getNFTContractInstance","nftContractAddress","contractAddresses","nftABI","actions","walletConnectProvider","WalletConnectProvider","rpc","chainId","qrcode","metamaskConnectInit","Promise","resolve","reject","Web3","currentProvider","providers","HttpProvider","enable","connector","on","err","payload","uri","WalletConnectQRCodeModal","open","close","reason","Number","connected","fetchNetworkId","getContractAddresses","escrowContractAddres","create","baseURL","expiryTime"],"mappings":"2LAMaA,EAAkB,CAC7BC,I,8CACAC,K,8CACAC,I,2FAGF,WAAoBC,EAAKC,GAAzB,mBAAAC,EAAA,6DACQC,EAAQC,aAAaC,QAAQ,kBAC7BC,EAASH,EACX,CAAE,eAAgB,mBAAoB,eAAgBA,GACtD,CACE,eAAgB,oBALxB,kBAS2BI,IAAMT,KAAKE,EAAKC,EAAQ,CAAEO,QAASF,IAT9D,cASUG,EATV,yBAUWA,GAVX,yH,kEAiBA,WAAmBT,EAAKU,GAAxB,mBAAAR,EAAA,6DACQC,EAAQC,aAAaC,QAAQ,kBAC7BC,EAASI,EACX,CAAE,eAAgBP,EAAO,eAAgB,oBACzC,CACE,eAAgB,oBALxB,kBAQ2BI,IAAMV,IAAIG,EAAK,CAAEQ,QAASF,IARrD,cAQUG,EARV,yBASWA,GATX,yH,kEAeA,WAAmBT,EAAKW,GAAxB,mBAAAT,EAAA,6DACQC,EAAQC,aAAaC,QAAQ,kBAC7BC,EAASH,EACX,CAAE,eAAgBA,GAClB,CACE,eAAgB,oBALxB,kBAQ2BI,IAAMR,IAAIC,EAAKW,EAAY,CAAEH,QAASF,IARjE,cAQUG,EARV,yBASWA,GATX,yH,kEC1CA,sBAAAP,EAAA,+EAEiBU,OAAOC,SAASC,QAAQ,CAAEC,OAAQ,gBAFnD,iGAIW,GAJX,yD,+BAOeC,E,8EAAf,WAAuBC,GAAvB,iBAAAf,EAAA,0DACMgB,IADN,wBAEQC,EAAW,CACbC,YAAY,EACZC,SAAU,IAJhB,kBAOiCH,IAAKI,IAAIC,cAP1C,YAOYC,EAPZ,QASuBC,OATvB,wBAUQN,EAASE,SAAWG,EAChBP,IACFE,EAASC,YAAa,GAZhC,kBAceD,GAdf,iCAgBeA,GAhBf,mFAmBaA,GAnBb,2D,kEAwBA,4BAAAjB,EAAA,+EAEUwB,cAFV,uBAGuBV,IAHvB,cAGUW,EAHV,yBAIWA,GAJX,oCAMwB,QAAhB,KAAMC,KANd,0CAOa,CACLR,YAAY,EACZC,SAAU,KATlB,iCAYW,CACLD,YAAY,EACZC,SAAU,KAdhB,0D,kEAkBA,4BAAAnB,EAAA,+EAEUU,OAAOC,SAASgB,KAAK,uBAF/B,uBAGuBb,IAHvB,cAGUW,EAHV,yBAIWA,GAJX,oCAMwB,QAAhB,KAAMC,KANd,0CAOa,CACLE,OAAO,EACPF,KAAM,KAAMA,KACZG,IAAK,KAAMC,QACXZ,YAAY,EACZC,SAAU,KAZlB,WAeuB,OAAf,KAAMO,KAfd,0CAgBa,CACLE,OAAO,EACPF,KAAM,KAAMA,KACZG,IAAK,KAAMC,QACXZ,YAAY,EACZC,SAAU,KArBlB,iCAwBW,CACLS,OAAO,EACPF,KAAM,KAAMA,KACZG,IAAK,KAAMC,QACXZ,YAAY,EACZC,SAAU,KA7BhB,0D,kEAkCA,WAAmCY,EAAaC,GAAhD,eAAAhC,EAAA,mEAEQgB,IAFR,gCAGqC,IAAIA,IAAKI,IAAIa,SAC1CF,EACAC,GALR,cAGYE,EAHZ,yBAOaA,GAPb,iH,sBAcO,IAAMC,EAAe,CAC1BC,a,2CACAC,e,2CACAC,oB,8CACAxB,UACAyB,qB,4CCrGWC,EAAQ,2BAAQ9C,GAAoByC,I,mHCDpCM,EAAc,CACzBC,aA2BF,WACE,OAAO,SAACC,GAEN,OADiBH,IAAS7C,IAAT,sBACDiD,MAAK,SAACC,GAChBA,EAAQC,MACVH,EAASI,EAAY,sBAAuBF,EAAQC,KAAKA,YA/B/DE,SAuCF,WACE,OAAO,SAACL,GAEN,OADiBH,IAAS7C,IAAT,oBACDiD,MAAK,SAACC,GAChBA,EAAQC,MACVH,EAASI,EAAY,eAAgBF,EAAQC,KAAKA,YA3CxDG,kBAmDF,WACE,OAAO,SAACN,GAEN,OADiBH,IAAS7C,IAAT,+BACDiD,MAAK,SAACC,GAChBA,EAAQC,MACVH,EAASI,EAAY,0BAA2BF,EAAQC,KAAKA,YAvDnEI,qBA+DF,WACE,OAAO,SAACP,GAEN,OADiBH,IAAS7C,IAAT,yBACDiD,MAAK,SAACC,GAChBA,EAAQC,MACVH,EAASI,EAAY,oBAAqBF,EAAQC,KAAKA,YAnE7DK,YA2EF,WAAiC,IAAZpD,EAAW,uDAAJ,GAC1B,8CAAO,WAAO4C,GAAP,SAAA3C,EAAA,sDACYwC,IAAS5C,KAAT,2BAA0CG,GAClD6C,MAAK,SAACC,GACU,MAAnBA,EAAQO,SACVT,EAASI,EAAY,qBAAsBF,EAAQC,KAAKO,aACxDV,EAASI,EAAY,mBAAoBF,EAAQC,KAAKA,WALrD,2CAAP,uDA3EAQ,gBAwFF,WAAqC,IAAZvD,EAAW,uDAAJ,GAC9B,8CAAO,WAAO4C,GAAP,SAAA3C,EAAA,sDACYwC,IAAS5C,KAAT,2BAA0CG,GAClD6C,MAAK,SAACC,GACU,MAAnBA,EAAQO,SACVT,EAASI,EAAY,qBAAsBF,EAAQC,KAAKO,aACxDV,EAASI,EAAY,wBAAyBF,EAAQC,KAAKA,WAL1D,2CAAP,uDAxFAS,kBAqGF,WAAuC,IAAZxD,EAAW,uDAAJ,GAChC,8CAAO,WAAO4C,GAAP,SAAA3C,EAAA,sDACYwC,IAAS5C,KAAT,sBAAqCG,GAC7C6C,MAAK,SAACC,GACU,MAAnBA,EAAQO,SACVT,EAASI,EAAY,qBAAsBF,EAAQC,KAAKO,aACxDV,EAASI,EAAY,sBAAuBF,EAAQC,KAAKA,WALxD,2CAAP,uDArGAU,sBAkHF,WAA2C,IAAZzD,EAAW,uDAAJ,GACpC,8CAAO,WAAO4C,GAAP,SAAA3C,EAAA,sDACYwC,IAAS5C,KAAT,sBAAqCG,GAC7C6C,MAAK,SAACC,GACU,MAAnBA,EAAQO,SACVT,EAASI,EAAY,qBAAsBF,EAAQC,KAAKO,aACxDV,EAASI,EAAY,2BAA4BF,EAAQC,KAAKA,WAL7D,2CAAP,uDAlHAW,eA+HF,WAAoC,IAAZ1D,EAAW,uDAAJ,GAC7B,8CAAO,WAAO4C,GAAP,SAAA3C,EAAA,sDACYwC,IAAS5C,KAAT,sBAAqCG,GAC7C6C,MAAK,SAACC,GACU,MAAnBA,EAAQO,SACVT,EAASI,EAAY,qBAAsBF,EAAQC,KAAKO,aACxDV,EAASI,EAAY,sBAAuBF,EAAQC,KAAKA,WALxD,2CAAP,uDA/HAY,qBA0JF,WAA0C,IAAZ3D,EAAW,uDAAJ,GACnC,8CAAO,WAAO4C,GAAP,SAAA3C,EAAA,sDACYwC,IAAS7C,IAAT,gCAAsCI,EAAO4D,KAAM,GAC3Df,MAAK,SAACC,GACU,MAAnBA,EAAQO,QACVT,EAASI,EAAY,4BAA6BF,EAAQC,KAAKA,UAJ9D,2CAAP,uDA1JAc,mBA2IF,WAAwC,IAAZ7D,EAAW,uDAAJ,GACjC,8CAAO,WAAO4C,GAAP,SAAA3C,EAAA,sDACYwC,IAAS5C,KAAT,sBAAqCG,GAC7C6C,MAAK,SAACC,GACU,MAAnBA,EAAQO,SACVT,EAASI,EAAY,qBAAsBF,EAAQC,KAAKO,aACxDV,EAASI,EAAY,2BAA4BF,EAAQC,KAAKA,WAL7D,2CAAP,uDA3IAe,iBAqKF,WAAwC,IAAd9D,EAAa,uDAAJ,GACjC,8CAAO,WAAO4C,GAAP,SAAA3C,EAAA,sDACYwC,IAAS3C,IAAT,+BAAqCE,EAAO4D,IAAM5D,GAC1D6C,MAAK,SAACC,GACU,MAAnBA,EAAQO,QACVT,EAASI,EAAY,qBAAsBF,EAAQC,UAJlD,2CAAP,uDArKAgB,UAiLF,WACE,OAAO,SAACnB,GAEN,OADiBH,IAAS7C,IAAT,uBAAoC,GACrCiD,MAAK,SAACC,GAChBA,EAAQC,MACVH,EAASI,EAAY,kBAAmBF,EAAQC,KAAKA,YArL3DiB,iBA6LF,WACE,OAAO,SAACpB,GAEN,OADiBH,IAAS7C,IAAT,iCAA8C,GAC/CiD,MAAK,SAACC,GAChBA,EAAQC,MACVH,EAASI,EAAY,yBAA0BF,EAAQC,KAAKA,YAjMlEkB,eAyMF,WACE,OAAO,SAACrB,GAEN,OADiBH,IAAS7C,IAAT,4BACDiD,MAAK,SAACC,GAChBA,EAAQC,MACVH,EAASI,EAAY,uBAAwBF,EAAQC,KAAKA,YA7MhEmB,qBAqNF,WACE,OAAO,SAACtB,GAEN,OADiBH,IAAS7C,IAAT,4BACDiD,MAAK,SAACC,GAChBA,EAAQC,MACVH,EAASI,EAAY,gCAAiCF,EAAQC,KAAKA,YAzNzEoB,sBAiOF,WACE,OAAO,SAACvB,GAEN,OADiBH,IAAS7C,IAAT,6BACDiD,MAAK,SAACC,GAChBA,EAAQC,MACVH,EAASI,EAAY,iCAAkCF,EAAQC,KAAKA,YArO1EqB,wBA6OF,WACE,OAAO,SAACxB,GAEN,OADiBH,IAAS7C,IAAT,+BACDiD,MAAK,SAACC,GAChBA,EAAQC,MACVH,EAASI,EAAY,mCAAoCF,EAAQC,KAAKA,aA/O9E,SAASC,EAAYqB,EAAMtB,GACzB,MAAO,CACLsB,KAAMA,EACNtB,KAAMA,GCxBH,IAAMuB,EAAc,CACzBC,gBAiCF,WACE,8CAAO,WAAO3B,GAAP,iBAAA3C,EAAA,6DACCO,EAAWiC,IAAS7C,IAAT,kBADZ,SAEiBY,EAFjB,QAECsC,EAFD,QAGOC,MACVH,EAASI,EAAY,qBAAsBF,EAAQC,KAAKA,OAJrD,2CAAP,uDAjCAyB,WA4CF,SAAoBC,GAClB,OAAO,SAAC7B,GACWH,IAAS7C,IAAT,kCAAwC6E,IAAU,GAC1D5B,MAAK,SAACC,GACU,MAAnBA,EAAQO,QACVT,EAASI,EAAY,kBAAmBF,EAAQC,KAAKA,YAhD3D2B,WA8EF,SAAoBd,EAAIe,GACtB,8CAAO,WAAO/B,GAAP,SAAA3C,EAAA,sDACYwC,IAAS7C,IACxBgE,EAAE,4BACuBA,EADvB,mBACoCe,GADpC,mCAE8BA,IAChC,GAEO9B,MAAK,SAACC,GACU,MAAnBA,EAAQO,QACVT,EAASI,EAAY,mBAAoBF,EAAQC,KAAKA,UATrD,2CAAP,uDA9EAK,YA4GF,WAAmC,IAAdpD,EAAa,uDAAJ,GAC5B,8CAAO,WAAO4C,GAAP,SAAA3C,EAAA,sDACYwC,IAAS5C,KAAT,2BAA0CG,GAClD6C,MAAK,SAACC,GACU,MAAnBA,EAAQO,SACVT,EAASI,EAAY,qBAAsBF,EAAQC,KAAKO,aACxDV,EAASI,EAAY,mBAAoBF,EAAQC,KAAKA,WALrD,2CAAP,uDA5GA6B,kBAsDF,SAA2B5E,GACzB,8CAAO,WAAO4C,GAAP,eAAA3C,EAAA,sDACL,KACQO,EAAWiC,IAAS3C,IAAT,cAA4BE,IACpC6C,MAAK,SAACC,GACU,MAAnBA,EAAQO,QACVT,EAASI,EAAY,kBAAmBF,EAAQC,KAAKA,UAKzDvC,EAASqC,MAAK,SAACE,GACTA,EAAKvC,UACPoC,EAASI,EAAY,aAAcD,EAAKvC,SAASuC,KAAKhB,aAG1D,MAAOF,IAfJ,2CAAP,uDAtDA0B,gBAwHF,WAAuC,IAAdvD,EAAa,uDAAJ,GAChC,8CAAO,WAAO4C,GAAP,SAAA3C,EAAA,sDACYwC,IAAS5C,KAAT,2BAA0CG,GAClD6C,MAAK,SAACC,GACU,MAAnBA,EAAQO,SACVT,EAASI,EAAY,qBAAsBF,EAAQC,KAAKO,aACxDV,EAASI,EAAY,wBAAyBF,EAAQC,KAAKA,WAL1D,2CAAP,uDAxHA8B,iBA2FF,SAA0B9B,GACxB,IAAI/C,EAAS8E,KAAKC,UAAUhC,GAC5B,8CAAO,WAAOH,GAAP,SAAA3C,EAAA,sDACYwC,IAAS5C,KAAK,oBAAqBG,GAC3C6C,MAAK,SAACC,GACU,MAAnBA,EAAQO,OACVT,EAASI,EAAY,oBAAqBF,EAAQC,OAElDH,EAASI,EAAY,oBAAqBF,EAAQtC,SAASuC,UAN1D,2CAAP,uDA5FAiC,gBAoIF,WACE,8CAAO,WAAOpC,GAAP,SAAA3C,EAAA,sDACYwC,IAAS7C,IAAT,kCAA+C,GACvDiD,MAAK,SAACC,GACU,MAAnBA,EAAQO,QACVT,EAASI,EAAY,yBAA0BF,EAAQC,KAAKA,UAJ3D,2CAAP,uDApIAkC,oB,4CACAC,gBACAC,YA8KF,SAAqBvB,GACnB,8CAAO,WAAOhB,GAAP,SAAA3C,EAAA,sDACYwC,IAAS7C,IAAT,sBAA4BgE,IAAM,GAC1Cf,MAAK,SAACC,GACU,MAAnBA,EAAQO,SACVT,EAASwC,EAAWxB,IACpBhB,EAASsC,EAActB,QALtB,2CAAP,uDA9KAwB,aACAC,cACAC,cAmNF,SAAuB1B,GACrB,8CAAO,WAAOhB,GAAP,SAAA3C,EAAA,sDACYwC,IAAS7C,IAAT,wBAA8BgE,IAAM,GAC5Cf,MAAK,SAACC,GACU,MAAnBA,EAAQO,QACVT,EAASyC,EAAYzB,OAJpB,2CAAP,uDAnNA2B,YA+NF,SAAqB3B,GACnB,8CAAO,WAAOhB,GAAP,SAAA3C,EAAA,sDACYwC,IAAS7C,IACxBgE,EAAE,2BAAuBA,GAAvB,oBACF,GAEOf,MAAK,SAACC,GACU,MAAnBA,EAAQO,QACVT,EAASI,EAAY,oBAAqBF,EAAQC,KAAKA,UAPtD,2CAAP,uDA/NAyC,gBA8OF,SAAyB5B,GACvB,8CAAO,WAAOhB,GAAP,SAAA3C,EAAA,sDACYwC,IAAS7C,IACxBgE,EAAE,+BAA2BA,GAA3B,wBACF,GAEOf,MAAK,SAACC,GACU,MAAnBA,EAAQO,QACVT,EAASI,EAAY,wBAAyBF,EAAQC,KAAKA,UAP1D,2CAAP,uDA9OA0C,iBA6PF,SAA0B7B,GACxB,8CAAO,WAAOhB,GAAP,SAAA3C,EAAA,sDACYwC,IAAS7C,IACxBgE,EAAE,6BAAyBA,GAAzB,sBACF,GAEOf,MAAK,SAACC,GACU,MAAnBA,EAAQO,QACVT,EAASI,EAAY,yBAA0BF,EAAQC,KAAKA,UAP3D,2CAAP,uDA7PA2C,kBA4QF,SAA2BC,EAAOC,GAChC,8CAAO,WAAOhD,GAAP,SAAA3C,EAAA,sDACYwC,IAAS7C,IAAT,sBAA4B+F,EAA5B,YAAqCC,IAC7C/C,MAAK,SAACC,GACU,MAAnBA,EAAQO,QACVT,EAASI,EAAY,8BAA+BF,EAAQC,KAAKA,UAJhE,2CAAP,uDA5QA8C,iBAwRF,WACE,8CAAO,WAAOjD,GAAP,SAAA3C,EAAA,sDACYwC,IAAS7C,IAAT,qBAAkC,GAC1CiD,MAAK,SAACC,GACU,MAAnBA,EAAQO,QACVT,EAASI,EAAY,wBAAyBF,EAAQC,KAAKA,UAJ1D,2CAAP,uDAxRA+C,iBAoSF,WACE,OAAO,SAAClD,GAEN,OADiBH,IAAS7C,IAAT,4BACDiD,MAAK,SAACC,GAChBA,EAAQC,MACVH,EAASI,EAAY,0BAA2BF,EAAQC,KAAKA,YAxSnEgD,YAgTF,SAAqBC,GACnB,OAAO,SAACpD,GAINA,EAASI,EAAY,eAAgBgD,MApTvCC,kBA2TF,SAA2BtE,GACzB,OAAO,SAACiB,GAEN,OADiBH,IAAS5C,KAAT,0BAAyC,CAAE8B,KAAMA,IAClDkB,MAAK,SAACC,GAChBA,EAAQC,MACVH,EAASI,EAAY,wBAAyBF,EAAQO,cA/T5D6C,sBAsUF,WACE,OAAO,SAACtD,GAEN,OADiBH,IAAS7C,IAAT,8BAA2C,GAC5CiD,MAAK,SAACC,GAChBA,EAAQC,MACVH,EAASI,EAAY,uBAAwBF,EAAQC,KAAKA,YA1UhEoD,gBAiVF,SAAyBC,EAAaC,GACpC,OAAO,SAACzD,GAKN,OAJiBH,IAAS5C,KAAT,wBAAuC,CACtDwG,eAAgBA,EAChBD,YAAaA,IAECvD,MAAK,SAACC,GAChBA,EAAQC,MACVH,EAASI,EAAY,sBAAuBF,EAAQO,eAtV5D,SAASL,EAAYqB,EAAMtB,GACzB,MAAO,CACLsB,KAAMA,EACNtB,KAAMA,G,4CA2HV,WAAmCa,GAAnC,eAAA3D,EAAA,sEAGyBwC,IAAS7C,IAAT,qBAA2BgE,IAAM,GAH1D,UAQ0B,OALlBpD,EAHR,QAQe6C,OARf,yCAUW7C,EAASuC,KAAKA,MAVzB,gCAaW,MAbX,4C,sBAoBA,SAASmC,EAActB,GACrB,8CAAO,WAAOhB,GAAP,SAAA3C,EAAA,sDACYwC,IAAS7C,IAAT,6BAAmCgE,IAC3Cf,MAAK,SAACC,GACU,MAAnBA,EAAQO,QACVT,EAASI,EAAY,sBAAuBF,EAAQC,KAAKA,UAJxD,2CAAP,sDAyBF,SAASqC,EAAWxB,GAClB,8CAAO,WAAOhB,GAAP,SAAA3C,EAAA,sDACYwC,IAAS7C,IAAT,uBAA6BgE,IAAM,GAC3Cf,MAAK,SAACC,GACU,MAAnBA,EAAQO,QACVT,EAASI,EAAY,mBAAoBF,EAAQC,KAAKA,UAJrD,2CAAP,sDAYF,SAASsC,EAAYzB,GACnB,8CAAO,WAAOhB,GAAP,SAAA3C,EAAA,sDACYwC,IAAS7C,IAAT,iCAAuCgE,IAAM,GACrDf,MAAK,SAACC,GACU,MAAnBA,EAAQO,QACVT,EAASI,EAAY,oBAAqBF,EAAQC,KAAKA,UAJtD,2CAAP,sDCrNF,SAASuD,EAAQvD,EAAMsB,GACrB,MAAO,CACLA,KAAMA,EACNtB,KAAMA,GAsJH,IAAMwD,EAAc,CACzBC,OAnJF,SAAgBzD,GACd,OAAO,SAACH,GACN,IACI5C,EAAS8E,KAAKC,UAAUhC,GACXN,IAAS5C,KAFd,aAEwBG,GAC3B6C,MAAK,SAACC,GACU,MAAnBA,EAAQO,QACVT,EAAS0D,EAAQxD,EAAQC,KAAKA,KAAM,iBA6I1C0D,UAtIF,SAAmBC,EAAOC,GACxB,OAAO,SAAC/D,GACN,IACI5C,EAAS8E,KAAKC,UAAU,CAC1B2B,MAAOA,EACPC,UAAWA,IAEIlE,IAAS5C,KALd,aAKwBG,GAC3B6C,KAAT,uCAAc,WAAOC,GAAP,eAAA7C,EAAA,yDACW,MAAnB6C,EAAQO,OADA,oBAEVlD,aAAayG,QAAQ,iBAAkB9D,EAAQC,KAAKA,KAAK7C,QACrD4C,EAAQC,KAAKA,KAAK7C,MAHZ,gCAIcuC,IAAS1B,UAJvB,OAIF8F,EAJE,OAKR1G,aAAayG,QAAQ,cAAeC,EAAQzF,SAAS,IACrDyF,EAAQ1F,YAAa,EACrByB,EAAS0D,EAAQO,EAAS,oBAPlB,OASVjE,EACE0D,EACE,CAAEvD,KAAMD,EAAQC,KAAKA,KAAK+D,QAASzD,QAAQ,GAC3C,eAZM,wBAgBVlD,aAAayG,QAAQ,iBAAkB,IAhB7B,4CAAd,yDA+HFG,cA1GF,SAAuBC,GACrB,8CAAO,WAAOpE,GAAP,eAAA3C,EAAA,sDACCF,EADD,4BAC4BiH,GAChBvE,IAAS7C,IAAIG,GACrB8C,MAAK,SAACC,GACU,MAAnBA,EAAQO,QACVT,EAAS0D,EAAQxD,EAAQC,KAAKA,KAAK2D,MAAO,sBALzC,2CAAP,uDA0GAO,gBA9FF,WACE,8CAAO,WAAOrE,GAAP,SAAA3C,EAAA,sEAEYwC,IAAS7C,IAFrB,iBAGIiD,MAAK,SAACC,GACU,MAAnBA,EAAQO,QACVT,EAAS0D,EAAQxD,EAAQC,KAAKA,KAAM,qBALnC,2CAAP,uDA8FAmE,kBAlFF,WACE,8CAAO,WAAOtE,GAAP,SAAA3C,EAAA,2EAEYwC,IAAS7C,IAFrB,sBAE8B,GAC1BiD,MAAK,SAACC,GACU,MAAnBA,EAAQO,QACVT,EAAS0D,EAAQxD,EAAQC,KAAKA,KAAM,uBALnC,2CAAP,uDAkFAoE,eA1DF,WACE,OAAO,SAACvE,GACWH,IAAS7C,IAAI,oBAAoB,GACzCiD,KAAT,uCAAc,WAAOC,GAAP,iBAAA7C,EAAA,yDACW,MAAnB6C,EAAQO,OADA,qBAENP,EAAQC,KAAKA,KAFP,gCAGcN,IAAS1B,UAHvB,OAGF8F,EAHE,OAIR1G,aAAayG,QAAQ,cAAeC,EAAQzF,SAAS,IACrDyF,EAAQ1F,YAAa,EACrByB,EAAS0D,EAAQO,EAAS,oBANlB,OAQVjE,EAAS0D,EAAQxD,EAAQC,KAAM,eARrB,wBAUV5C,aAAayG,QAAQ,iBAAkB,IAClC9D,EAAQtC,UAAyC,OAA7B,UAAAsC,EAAQtC,gBAAR,eAAkB6C,SACzCT,EAAS0D,EAAQxD,EAAQtC,SAAU,qBAZ3B,4CAAd,yDAwDF4G,eArCF,SAAwBxD,GACtB,8CAAO,WAAOhB,GAAP,SAAA3C,EAAA,sDACYwC,IAAS7C,IAAT,6BAAmCgE,IAC3Cf,MAAK,SAACC,GACU,MAAnBA,EAAQO,QACVT,EAAS0D,EAAQxD,EAAQC,KAAKA,KAAM,4BAJnC,2CAAP,uDAqCAsE,UAzBF,SAAmBtE,GACjB,OAAO,SAACH,GACN,IAAM7C,EAAG,wBAAoBgD,EAAKa,IACjBnB,IAAS3C,IAAIC,EAAKgD,GAAMF,MAAK,SAACrC,GACrB,MAApBA,EAAS6C,QACXT,EAAS0D,EAAQ9F,EAASuC,KAAM,eAE9BvC,EAASA,UAAyC,MAA7BA,EAASA,SAAS6C,QACzCT,EAAS0D,EAAQ9F,EAASA,SAASuC,KAAM,eAEvCvC,EAASA,UAAyC,MAA7BA,EAASA,SAAS6C,QACzCT,EAAS0D,EAAQ9F,EAASA,SAASuC,KAAM,qB,kBC1IjD,SAASuE,EAAgBvE,EAAMsB,GAC7B,MAAO,CAAEtB,KAAMA,EAAMsB,KAAMA,GAuFtB,IAAMkD,EAAc,CACzBlF,aApFF,WACE,OAAO,SAACO,GACWH,IAASJ,eACjBQ,MAAK,SAACC,GACbF,EAAS0E,EAAgBxE,EAAS,0BAiFtC/B,QA5EF,SAAiByG,GACf,OAAIA,EACK,SAAC5E,GACNA,EAAS0E,EAAgB,KAAM,qBAG1B,SAAC1E,GACWH,IAAS1B,UACjB8B,MAAK,SAACC,GACb,OAAIA,QAAJ,IAAIA,KAAS1B,SAAS,GACpBwB,EAAS0E,EAAgBxE,EAAS,oBAElC3C,aAAasH,aAiErBnF,eA9CF,WACE,OAAO,SAACM,GACWH,IAASH,iBACjBO,MAAK,SAACC,GAERA,EAAQjB,MAKXe,EAAS0E,EAAgBxE,EAAS,0BAHlCF,EAAS0E,EAAgBxE,EAAS,yBAwCxC4E,gBAhCF,SAAyBC,GACvB,OAAO,SAAC/E,GACWH,IAASiF,gBAAgBC,GACjC9E,MAAK,SAACC,GACTA,GACFF,EAvEC,CACLyB,KAAM,sBACNtB,KAqE+BD,SA4BjC8E,uBApBF,WACE,IAAQC,EAAuBC,cAAvBD,mBACR,OAAO,SAACjF,GACWH,IAASF,oBAAoBwF,EAAQF,GAC7ChF,MAAK,SAACC,GAETA,GACFF,EAAS0E,EAAgBxE,EAAS,+BAcxCN,qBA7DF,WACE,OAAO,SAACI,GACWH,IAASD,uBACjBK,MAAK,SAACC,GACTA,GACFF,EAAS0E,EAAgBxE,EAAS,0BC3C7BkF,EAAO,mDACbtF,GACA6D,GACAgB,GACAjD,I,iCCVP,uJAIIrD,EAAO,KACPgH,EAAwB,IAAIC,IAAsB,CACpDC,IAAK,CACH,GAAM,oFAGRC,QAAS,GAETC,QAAQ,IAGJC,EAAsB,WAE1B,OAAO,IAAIC,SAAQ,SAACC,EAASC,GACA,qBAAhB9H,OAAOM,MAEhBA,EAAO,IAAIyH,IAAK/H,OAAOM,KAAK0H,iBAC5BxI,aAAayG,QAAQ,gBAAiB,GACtC4B,GAAQ,KAKRvH,EAAO,IAAIyH,IACT,IAAIA,IAAKE,UAAUC,aACjB,sCAIJJ,GAAO,QAoBPhH,EAAyB,WAC7B,OAAO,IAAI8G,SAAQ,SAACC,EAASC,GAC3BtI,aAAayG,QAAQ,gBAAiB,GACtCqB,EAAsBa,SACtB7H,EAAO,IAAIyH,IAAKT,GAEhBA,EAAsBc,UAAUC,GAAG,eAAe,SAACC,EAAKC,GACtD,IAAMC,EAAMD,EAAQlJ,OAAO,GAC3BoJ,IAAyBC,KAAKF,MAEhClB,EAAsBe,GAAG,WAAW,WAClCI,IAAyBE,WAE3BrB,EAAsBe,GAAG,cAAc,SAACrH,EAAM4H,GAE5CpJ,aAAasH,WAEfe,GAAQ,OAIPvH,IACCuI,OAAOrJ,aAAaC,QAAQ,kBAAoB,EAnC7C,IAAImI,SAAQ,SAACC,EAASC,GACtBR,EAAsBc,UAAUU,WAKnCxB,EAAsBa,SACtB7H,EAAO,IAAIyH,IAAKT,GAChBO,GAAQ,KANRF,IACAG,GAAO,OAkCJH,M,qHC3ET,sBAAArI,EAAA,sEACoBwC,IAASJ,eAD7B,0D,0DAGAqH,GAsBeC,IApBf,WACE,MACS,CACLzJ,MAAO,6CACP2H,mBAAoB,6CACpB+B,qBAAsB,gD,07PCZ5B,wDAEetJ,QAAMuJ,OAAO,CAC1BC,QAAS,wCAOJ,IAMMC,EAAa,G","file":"static/js/5.e0979d36.chunk.js","sourcesContent":["import axios from \"../config\";\nimport { web3 } from \"../web3\";\n// import userBalancesContract from \"../contracts/userBalances/userBalances\";\n// import tokens from \"../tokens.json\";\n// import { param } from \"jquery\";\n\nexport const backendServices = {\n  get,\n  post,\n  put,\n};\n\nasync function post(url, params) {\n  const token = localStorage.getItem(\"fibitAuthToken\");\n  const header = token\n    ? { \"content-type\": \"application/json\", \"x-auth-token\": token }\n    : {\n        \"content-type\": \"application/json\",\n      };\n  // console.log(\"this\", header);\n  try {\n    const response = await axios.post(url, params, { headers: header });\n    return response;\n  } catch (error) {\n    // console.log(\"new\", error.response);\n    return error;\n  }\n}\n\nasync function get(url, isAuthenticated) {\n  const token = localStorage.getItem(\"fibitAuthToken\");\n  const header = isAuthenticated\n    ? { \"x-auth-token\": token, \"content-type\": \"application/json\" }\n    : {\n        \"content-type\": \"application/json\",\n      };\n  try {\n    const response = await axios.get(url, { headers: header });\n    return response;\n  } catch (error) {\n    return error;\n  }\n}\n\nasync function put(url, parameters) {\n  const token = localStorage.getItem(\"fibitAuthToken\");\n  const header = token\n    ? { \"x-auth-token\": token }\n    : {\n        \"content-type\": \"application/json\",\n      };\n  try {\n    const response = await axios.put(url, parameters, { headers: header });\n    return response;\n  } catch (error) {\n    return error;\n  }\n}\n\nlet web3Data = {\n  isLoggedIn: false,\n  accounts: [],\n};\n\n// async function getWeb3(val) {\n//   if (web3) {\n//     try {\n//       let web3Data = {\n//         isLoggedIn: false,\n//         accounts: [],\n//       };\n//       const responseData = await web3.eth.getAccounts();\n\n//       if (responseData.length) {\n//         web3Data.isLoggedIn = true;\n//         web3Data.accounts = responseData;\n//         return web3Data;\n//       } else {\n//         return web3Data;\n//       }\n//     } catch {\n//       return web3Data;\n//     }\n//   }\n// }\n","import { web3, walletConnectModalInit } from \"../web3\";\n\nasync function getNetworkId() {\n  try {\n    return await window.ethereum.request({ method: \"eth_chainId\" });\n  } catch (error) {\n    return 1;\n  }\n}\nasync function getWeb3(isAuthenticate) {\n  if (web3) {\n    let web3Data = {\n      isLoggedIn: false,\n      accounts: [],\n    };\n    try {\n      const responseData = await web3.eth.getAccounts();\n\n      if (responseData.length) {\n        web3Data.accounts = responseData;\n        if (isAuthenticate) {\n          web3Data.isLoggedIn = true;\n        }\n        return web3Data;\n      } else {\n        return web3Data;\n      }\n    } catch {\n      return web3Data;\n    }\n  }\n}\n\nasync function enabledWalletConnect() {\n  try {\n    await walletConnectModalInit();\n    const resp = await getWeb3();\n    return resp;\n  } catch (error) {\n    if (error.code === -32002) {\n      return {\n        isLoggedIn: false,\n        accounts: [],\n      };\n    }\n    return {\n      isLoggedIn: false,\n      accounts: [],\n    };\n  }\n}\nasync function enableMetamask() {\n  try {\n    await window.ethereum.send(\"eth_requestAccounts\");\n    const resp = await getWeb3();\n    return resp;\n  } catch (error) {\n    if (error.code === -32002) {\n      return {\n        error: true,\n        code: error.code,\n        msg: error.message,\n        isLoggedIn: false,\n        accounts: [],\n      };\n    }\n    if (error.code === 4001) {\n      return {\n        error: true,\n        code: error.code,\n        msg: error.message,\n        isLoggedIn: false,\n        accounts: [],\n      };\n    }\n    return {\n      error: true,\n      code: error.code,\n      msg: error.message,\n      isLoggedIn: false,\n      accounts: [],\n    };\n  }\n}\n\nasync function getContractInstance(contractAbi, contractAddress) {\n  try {\n    if (web3) {\n      const contractInstance = await new web3.eth.Contract(\n        contractAbi,\n        contractAddress\n      );\n      return contractInstance;\n    }\n  } catch (error) {\n    // console.log(error);\n  }\n}\n\nexport const web3Services = {\n  getNetworkId,\n  enableMetamask,\n  getContractInstance,\n  getWeb3,\n  enabledWalletConnect,\n};\n","import { backendServices } from './backend.service';\nimport { web3Services } from './web3.service';\n\nexport const services = { ...backendServices, ...web3Services };\n","import { services } from \"../services\";\n\nexport const authActions = {\n  fetchBanners,\n  fetcInfo,\n  fetcHallFrameInfo,\n  fetchDashboardConfig,\n  getCreators,\n  getMoreCreators,\n  getMarketPlaceNFT,\n  getMoreMarketPlaceNFT,\n  getCollections,\n  getCollectionDetails,\n  getMoreCollections,\n  updateCollection,\n  getTopNFT,\n  getTopCollection,\n  getProfileInfo,\n  getHallOfFrameArtist,\n  getHallOfFrameArtwork,\n  getHallOfFrameCollector,\n};\n\nfunction fetchedData(type, data) {\n  return {\n    type: type,\n    data: data,\n  };\n}\n\nfunction fetchBanners() {\n  return (dispatch) => {\n    const response = services.get(`/admin/banner/list`);\n    return response.then((promise) => {\n      if (promise.data) {\n        dispatch(fetchedData(\"FETCHED_NFT_BANNERS\", promise.data.data));\n      } else {\n        // console.log('error in getBanners actions');\n      }\n    });\n  };\n}\n\nfunction fetcInfo() {\n  return (dispatch) => {\n    const response = services.get(`/admin/info/list`);\n    return response.then((promise) => {\n      if (promise.data) {\n        dispatch(fetchedData(\"FETCHED_INFO\", promise.data.data));\n      } else {\n        // console.log('error in fetcInfo actions');\n      }\n    });\n  };\n}\n\nfunction fetcHallFrameInfo() {\n  return (dispatch) => {\n    const response = services.get(`/admin/hall-frame-info/list`);\n    return response.then((promise) => {\n      if (promise.data) {\n        dispatch(fetchedData('FETCHED_HALL_FRAME_INFO', promise.data.data));\n      } else {\n        // console.log('error in fetcHallFrameInfo actions');\n      }\n    });\n  };\n}\n\nfunction fetchDashboardConfig() {\n  return (dispatch) => {\n    const response = services.get(`/admin/dashboard/list`);\n    return response.then((promise) => {\n      if (promise.data) {\n        dispatch(fetchedData(\"FETCHED_DASHBOARD\", promise.data.data));\n      } else {\n        // console.log('error in fetchDashboardConfig actions');\n      }\n    });\n  };\n}\n\nfunction getCreators(params={}) {\n  return async (dispatch) => {\n    const response = services.post(`user/listVerifiefCreator`, params);\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(fetchedData(\"FETCHED_PAGINATION\", promise.data.pagination));\n        dispatch(fetchedData(\"FETCHED_CREATORS\", promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nfunction getMoreCreators(params={}) {\n  return async (dispatch) => {\n    const response = services.post(`user/listVerifiefCreator`, params);\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(fetchedData(\"FETCHED_PAGINATION\", promise.data.pagination));\n        dispatch(fetchedData(\"FETCHED_MORE_CREATORS\", promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nfunction getMarketPlaceNFT(params={}) {\n  return async (dispatch) => {\n    const response = services.post(`nft/listMarketPlace`, params);\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(fetchedData(\"FETCHED_PAGINATION\", promise.data.pagination));\n        dispatch(fetchedData(\"FETCHED_MARKETPLACE\", promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nfunction getMoreMarketPlaceNFT(params={}) {\n  return async (dispatch) => {\n    const response = services.post(`nft/listMarketPlace`, params);\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(fetchedData(\"FETCHED_PAGINATION\", promise.data.pagination));\n        dispatch(fetchedData(\"FETCHED_MORE_MARKETPLACE\", promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nfunction getCollections(params={}) {\n  return async (dispatch) => {\n    const response = services.post(`nft/listCollections`, params);\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(fetchedData(\"FETCHED_PAGINATION\", promise.data.pagination));\n        dispatch(fetchedData(\"FETCHED_COLLECTIONS\", promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nfunction getMoreCollections(params={}) {\n  return async (dispatch) => {\n    const response = services.post(`nft/listCollections`, params);\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(fetchedData(\"FETCHED_PAGINATION\", promise.data.pagination));\n        dispatch(fetchedData(\"FETCHED_MORE_COLLECTIONS\", promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nfunction getCollectionDetails(params={}) {\n  return async (dispatch) => {\n    const response = services.get(`nft/getCollectionInfo/${params.id}`, true);\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(fetchedData(\"FETCHED_COLLECTION_DETAIL\", promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nfunction updateCollection(params = {}) {\n  return async (dispatch) => {\n    const response = services.put(`nft/updateCollection/${params.id}`, params);\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(fetchedData(\"COLLECTION_UPDATED\", promise.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nfunction getTopNFT() {\n  return (dispatch) => {\n    const response = services.get(`/admin/popular/list`, true);\n    return response.then((promise) => {\n      if (promise.data) {\n        dispatch(fetchedData(\"FETCHED_TOP_NFT\", promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nfunction getTopCollection() {\n  return (dispatch) => {\n    const response = services.get(`/admin/popularCollection/list`, true);\n    return response.then((promise) => {\n      if (promise.data) {\n        dispatch(fetchedData(\"FETCHED_TOP_COLLECTION\", promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nfunction getProfileInfo() {\n  return (dispatch) => {\n    const response = services.get(`/admin/profile-info/list`);\n    return response.then((promise) => {\n      if (promise.data) {\n        dispatch(fetchedData(\"FETCHED_PROFILE_INFO\", promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nfunction getHallOfFrameArtist() {\n  return (dispatch) => {\n    const response = services.get(`/hallOfFrame/list/artist`);\n    return response.then((promise) => {\n      if (promise.data) {\n        dispatch(fetchedData(\"FETCHED_HALL_OF_FRAMES_ARTIST\", promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nfunction getHallOfFrameArtwork() {\n  return (dispatch) => {\n    const response = services.get(`/hallOfFrame/list/artwork`);\n    return response.then((promise) => {\n      if (promise.data) {\n        dispatch(fetchedData(\"FETCHED_HALL_OF_FRAMES_ARTWORK\", promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nfunction getHallOfFrameCollector() {\n  return (dispatch) => {\n    const response = services.get(`/hallOfFrame/list/collector`);\n    return response.then((promise) => {\n      if (promise.data) {\n        dispatch(fetchedData(\"FETCHED_HALL_OF_FRAMES_COLLECTOR\", promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}","import { services } from '../services';\n\nexport const userActions = {\n  fetchCategories,\n  getProfile,\n  getUserNFT,\n  getCreators,\n  updateUserDetails,\n  getMoreCreators,\n  createCollection,\n  getUserDraftNFT,\n  getSingleNFTDetails,\n  getLikesCount,\n  likeToggler,\n  getIsLiked,\n  getIsFollow,\n  followToggler,\n  getLikedNFT,\n  getCollectedNFT,\n  getCollectionNFT,\n  getEditionHistory,\n  getNotifications,\n  getProfileBanner,\n  setLanguage,\n  sendInstagramCode,\n  getTwitterAccessToken,\n  verifyByTwitter,\n};\n\nfunction fetchedData(type, data) {\n  return {\n    type: type,\n    data: data,\n  };\n}\n\nfunction fetchCategories() {\n  return async (dispatch) => {\n    const response = services.get(`/category/list`);\n    const promise = await response;\n    if (promise.data) {\n      dispatch(fetchedData('FETCHED_CATEGORIES', promise.data.data));\n    } else {\n      // console.log('error in fetchCategories actions');\n    }\n  };\n}\n\nfunction getProfile(userId) {\n  return (dispatch) => {\n    const response = services.get(`user/userDetails?userId=${userId}`, true);\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(fetchedData('FETCHED_PROFILE', promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nfunction updateUserDetails(params) {\n  return async (dispatch) => {\n    try {\n      const response = services.put(`user/update`, params);\n      response.then((promise) => {\n        if (promise.status === 200) {\n          dispatch(fetchedData('PROFILE_UPDATED', promise.data.data));\n        } else {\n          // console.log(\"error\");\n        }\n      });\n      response.then((data) => {\n        if (data.response) {\n          dispatch(fetchedData('API_FAILED', data.response.data.message));\n        }\n      });\n    } catch (error) {\n      // console.log(\"error\");\n    }\n  };\n}\n\nfunction getUserNFT(id, filter) {\n  return async (dispatch) => {\n    const response = services.get(\n      id\n        ? `nft/listNftByUser/${id}?status=${filter}`\n        : `nft/listNftByUser?status=${filter}`,\n      true\n    );\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(fetchedData('FETCHED_USER_NFT', promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\nfunction createCollection(data) {\n  let params = JSON.stringify(data);\n  return async (dispatch) => {\n    const response = services.post('nft/addCollection', params);\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(fetchedData('CREATE_COLLECTION', promise.data));\n      } else {\n        dispatch(fetchedData('CREATE_COLLECTION', promise.response.data));\n      }\n    });\n  };\n}\n\nfunction getCreators(params = {}) {\n  return async (dispatch) => {\n    const response = services.post(`user/listVerifiefCreator`, params);\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(fetchedData('FETCHED_PAGINATION', promise.data.pagination));\n        dispatch(fetchedData('FETCHED_CREATORS', promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nfunction getMoreCreators(params = {}) {\n  return async (dispatch) => {\n    const response = services.post(`user/listVerifiefCreator`, params);\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(fetchedData('FETCHED_PAGINATION', promise.data.pagination));\n        dispatch(fetchedData('FETCHED_MORE_CREATORS', promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nfunction getUserDraftNFT() {\n  return async (dispatch) => {\n    const response = services.get(`nft/listNftByUser?filter=draft`, true);\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(fetchedData('FETCHED_USER_DRAFT_NFT', promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nasync function getSingleNFTDetails(id) {\n  // console.log('called', id);\n  // return async (dispatch) => {\n  const response = await services.get(`nft/single/${id}`, true);\n  // console.log(\"called\",response)\n\n  // return promise.data.data;\n  // response.then((promise) => {\n  if (response.status === 200) {\n    // console.log(\"called\",response.data.data)\n    return response.data.data;\n  } else {\n    // console.log(\"called\",response)\n    return null;\n    // console.log(\"error\");\n  }\n  // });\n}\n// }\n\nfunction getLikesCount(id) {\n  return async (dispatch) => {\n    const response = services.get(`like/getLikesCount/${id}`);\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(fetchedData('FETCHED_LIKES_COUNT', promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\nfunction likeToggler(id) {\n  return async (dispatch) => {\n    const response = services.get(`like/toggle/${id}`, true);\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(getIsLiked(id));\n        dispatch(getLikesCount(id));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nfunction getIsLiked(id) {\n  return async (dispatch) => {\n    const response = services.get(`like/isLiked/${id}`, true);\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(fetchedData('FETCHED_IS_LIKED', promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nfunction getIsFollow(id) {\n  return async (dispatch) => {\n    const response = services.get(`follow/checkIsFollowed/${id}`, true);\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(fetchedData('FETCHED_IS_FOLLOW', promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nfunction followToggler(id) {\n  return async (dispatch) => {\n    const response = services.get(`follow/toggle/${id}`, true);\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(getIsFollow(id));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nfunction getLikedNFT(id) {\n  return async (dispatch) => {\n    const response = services.get(\n      id ? `nft/getLikedNfts/${id}` : `nft/getLikedNfts`,\n      true\n    );\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(fetchedData('FETCHED_LIKED_NFT', promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nfunction getCollectedNFT(id) {\n  return async (dispatch) => {\n    const response = services.get(\n      id ? `nft/getCollectedNfts/${id}` : `nft/getCollectedNfts`,\n      true\n    );\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(fetchedData('FETCHED_COLLECTED_NFT', promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nfunction getCollectionNFT(id) {\n  return async (dispatch) => {\n    const response = services.get(\n      id ? `nft/listCollection/${id}` : `nft/listCollection`,\n      true\n    );\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(fetchedData('FETCHED_COLLECTION_NFT', promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nfunction getEditionHistory(nftId, edition) {\n  return async (dispatch) => {\n    const response = services.get(`nft/history/${nftId}/${edition}`);\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(fetchedData('FETCHED_NFT_EDITION_HISTORY', promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nfunction getNotifications() {\n  return async (dispatch) => {\n    const response = services.get(`notification/list`, true);\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(fetchedData('FETCHED_NOTIFICATIONS', promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nfunction getProfileBanner() {\n  return (dispatch) => {\n    const response = services.get(`/admin/profile-info/list`);\n    return response.then((promise) => {\n      if (promise.data) {\n        dispatch(fetchedData('FETCHED_PROFILE_BANNERS', promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nfunction setLanguage(lng) {\n  return (dispatch) => {\n    // const response = services.get(`/admin/profile-info/list`);\n    // return response.then((promise) => {\n    //   if (promise.data) {\n    dispatch(fetchedData('SET_LANGUAGE', lng));\n    // } else {\n    //   // console.log(\"error\");\n    // }\n    // });\n  };\n}\nfunction sendInstagramCode(code) {\n  return (dispatch) => {\n    const response = services.post(`/user/validateInstagram`, { code: code });\n    return response.then((promise) => {\n      if (promise.data) {\n        dispatch(fetchedData('VERIFIED_BY_INSTAGRAM', promise.status));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\nfunction getTwitterAccessToken() {\n  return (dispatch) => {\n    const response = services.get(`/user/twitter/access_token`, true);\n    return response.then((promise) => {\n      if (promise.data) {\n        dispatch(fetchedData('TWITTER_ACCESS_TOKEN', promise.data.data));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\nfunction verifyByTwitter(oauth_token, oauth_verifier) {\n  return (dispatch) => {\n    const response = services.post(`/user/validateTwitter`, {\n      oauth_verifier: oauth_verifier,\n      oauth_token: oauth_token,\n    });\n    return response.then((promise) => {\n      if (promise.data) {\n        dispatch(fetchedData('VERIFIED_BY_TWITTER', promise.status));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n","import { services } from \"../services\";\n\nfunction setData(data, type) {\n  return {\n    type: type,\n    data: data,\n  };\n}\n\nfunction addNFT(data) {\n  return (dispatch) => {\n    const url = \"nft/addNft\";\n    let params = JSON.stringify(data);\n    const response = services.post(url, params);\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(setData(promise.data.data, \"ADD_NFT\"));\n      } else {\n        // console.log('erroer');\n      }\n    });\n  };\n}\nfunction authLogin(nonce, signature) {\n  return (dispatch) => {\n    const url = \"user/login\";\n    let params = JSON.stringify({\n      nonce: nonce,\n      signature: signature,\n    });\n    const response = services.post(url, params);\n    response.then(async (promise) => {\n      if (promise.status === 200) {\n        localStorage.setItem(\"fibitAuthToken\", promise.data.data.token);\n        if (promise.data.data.token) {\n          const newresp = await services.getWeb3();\n          localStorage.setItem(\"userAddress\", newresp.accounts[0]);\n          newresp.isLoggedIn = true;\n          dispatch(setData(newresp, \"FETCH_WEB3_DATA\"));\n        }\n        dispatch(\n          setData(\n            { data: promise.data.data.details, status: true },\n            \"AUTH_LOGIN\"\n          )\n        );\n      } else {\n        localStorage.setItem(\"fibitAuthToken\", \"\");\n      }\n    });\n  };\n}\nfunction generateNonce(address) {\n  return async (dispatch) => {\n    const url = `user/genrateNonce/${address}`;\n    const response = services.get(url);\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(setData(promise.data.data.nonce, \"GENERATE_NONCE\"));\n      } else {\n        // console.log(\"erroer\");\n      }\n    });\n  };\n}\nfunction getCategoryList() {\n  return async (dispatch) => {\n    const url = `category/list`;\n    const response = services.get(url);\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(setData(promise.data.data, \"CATEGORY_LIST\"));\n      } else {\n        // console.log(\"erroer\");\n      }\n    });\n  };\n}\nfunction getCollectionList() {\n  return async (dispatch) => {\n    const url = `nft/listCollection`;\n    const response = services.get(url, true);\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(setData(promise.data.data, \"COLLECTION_LIST\"));\n      } else {\n        // console.log(\"erroer\");\n      }\n    });\n  };\n}\n// function authenticateUser() {\n//   return (dispatch) => {\n//     const response = services.getWeb3(true);\n//     response.then((promise) => {\n//       if (promise.accounts[0]) {\n//         dispatch(setDispatchData(promise, \"FETCH_WEB3_DATA\"));\n//       } else {\n//         // console.log('errorrrr in actions');\n//       }\n//     });\n//   };\n// }\nfunction getUserDetails() {\n  return (dispatch) => {\n    const response = services.get(\"user/userDetails\", true);\n    response.then(async (promise) => {\n      if (promise.status === 200) {\n        if (promise.data.data) {\n          const newresp = await services.getWeb3();\n          localStorage.setItem(\"userAddress\", newresp.accounts[0]);\n          newresp.isLoggedIn = true;\n          dispatch(setData(newresp, \"FETCH_WEB3_DATA\"));\n        }\n        dispatch(setData(promise.data, \"AUTH_LOGIN\"));\n      } else {\n        localStorage.setItem(\"fibitAuthToken\", \"\");\n        if (!promise.response && promise.response?.status === 401) {\n          dispatch(setData(promise.response, \"AUTH_LOGIN_ERROR\"));\n        }\n      }\n    });\n  };\n}\n\nfunction getUserProfile(id) {\n  return async (dispatch) => {\n    const response = services.get(`user/getSingleUser/${id}`);\n    response.then((promise) => {\n      if (promise.status === 200) {\n        dispatch(setData(promise.data.data, \"FETCHED_USER_PROFILE\"));\n      } else {\n        // console.log(\"error\");\n      }\n    });\n  };\n}\n\nfunction updateNFT(data) {\n  return (dispatch) => {\n    const url = `nft/updateNft/${data.id}`;\n    const response = services.put(url, data).then((response) => {\n      if (response.status === 200) {\n        dispatch(setData(response.data, \"UPDATE_NFT\"));\n      }\n      if (response.response && response.response.status === 403) {\n        dispatch(setData(response.response.data, \"UPDATE_NFT\"));\n      }\n      if (response.response && response.response.status === 400) {\n        dispatch(setData(response.response.data, \"UPDATE_NFT\"));\n      }\n    });\n  };\n}\n\nexport const defiActions = {\n  addNFT,\n  authLogin,\n  generateNonce,\n  getCategoryList,\n  getCollectionList,\n  getUserDetails,\n  getUserProfile,\n  updateNFT,\n};\n","import { services } from '../services';\nimport nftABI from '../contractData/abis/nft.json';\nimport contractAddresses from '../contractData/contractAddress/addresses';\n\nfunction fetchUserBalances(data) {\n  return {\n    type: 'FETCH_USER_BALANCES', // dispatch user login event\n    data: data,\n  };\n}\n\nfunction setDispatchData(data, type) {\n  return { data: data, type: type };\n}\n\n// get defi categories\nfunction getNetworkId() {\n  return (dispatch) => {\n    const response = services.getNetworkId();\n    response.then((promise) => {\n      dispatch(setDispatchData(promise, 'FETCH_NETWORK_ID'));\n    });\n  };\n}\n\nfunction getWeb3(val) {\n  if (val) {\n    return (dispatch) => {\n      dispatch(setDispatchData(null, 'FETCH_WEB3_DATA'));\n    };\n  } else\n    return (dispatch) => {\n      const response = services.getWeb3();\n      response.then((promise) => {\n        if (promise?.accounts[0]) {\n          dispatch(setDispatchData(promise, 'FETCH_WEB3_DATA'));\n        } else {\n          localStorage.clear();\n          // console.log('errorrrr in actions');\n        }\n      });\n    };\n}\n\nfunction enabledWalletConnect() {\n  return (dispatch) => {\n    const response = services.enabledWalletConnect();\n    response.then((promise) => {\n      if (promise) {\n        dispatch(setDispatchData(promise, 'FETCH_WEB3_DATA'));\n      } else {\n        // console.log('error in actions');\n      }\n    });\n  };\n}\nfunction enableMetamask() {\n  return (dispatch) => {\n    const response = services.enableMetamask();\n    response.then((promise) => {\n      // console.log(\"present\");\n      if (!promise.error) {\n        // console.log(\"this is new actions\", promise);\n        dispatch(setDispatchData(promise, 'FETCH_WEB3_DATA'));\n      } else {\n        // console.log(\"i am in error\", promise);\n        dispatch(setDispatchData(promise, 'FETCH_WEB3_DATA_ERROR'));\n      }\n    });\n  };\n}\nfunction getUserBalances(userAddress) {\n  return (dispatch) => {\n    const response = services.getUserBalances(userAddress);\n    response.then((promise) => {\n      if (promise) {\n        dispatch(fetchUserBalances(promise));\n      } else {\n        // console.log('error in actions');\n      }\n    });\n  };\n}\n\nfunction getNFTContractInstance() {\n  const { nftContractAddress } = contractAddresses();\n  return (dispatch) => {\n    const response = services.getContractInstance(nftABI, nftContractAddress);\n    response.then((promise) => {\n      // console.log(promise);\n      if (promise) {\n        dispatch(setDispatchData(promise, 'NFT_CONTRACT_INSTANCE'));\n      } else {\n        // console.log('error in actions');\n      }\n    });\n  };\n}\n\nexport const web3Actions = {\n  getNetworkId,\n  getWeb3,\n  enableMetamask,\n  getUserBalances,\n  getNFTContractInstance,\n  enabledWalletConnect,\n};\n","import { authActions } from \"./auth.action\";\nimport { userActions } from \"./user.action\";\nimport { defiActions } from \"./defi.action\";\nimport { web3Actions } from \"./web3.action\";\n\n\nexport const actions = {\n    ...authActions,\n    ...defiActions,\n    ...web3Actions,\n    ...userActions,\n};","import WalletConnectProvider from '@walletconnect/web3-provider';\nimport Web3 from 'web3';\nimport WalletConnectQRCodeModal from '@walletconnect/qrcode-modal';\n\nlet web3 = null;\nlet walletConnectProvider = new WalletConnectProvider({\n  rpc: {\n    0x38: 'https://speedy-nodes-nyc.moralis.io/5be1af5bcc43ff8e4432ee14/bsc/mainnet/archive', // BSC Mainnet chainId - 56\n    // 0x61: 'https://data-seed-prebsc-1-s1.binance.org:8545/', // BSC Testnet chainId - 97\n  },\n  chainId: 56, // BSC Mainnet\n  // chainId: 0x61, // BSC Testnet\n  qrcode: false,\n});\n\nconst metamaskConnectInit = () => {\n  // Check if Web3 has been injected by the browser (Mist/MetaMask).\n  return new Promise((resolve, reject) => {\n    if (typeof window.web3 !== 'undefined') {\n      // Use Mist/MetaMask's provider.\n      web3 = new Web3(window.web3.currentProvider);\n      localStorage.setItem('walletConnect', 0);\n      resolve(true);\n    } else {\n      // Handle the case where the user doesn't have web3. Probably\n      // show them a message telling them to install Metamask in\n      // order to use the app.\n      web3 = new Web3(\n        new Web3.providers.HttpProvider(\n          'https://bsc-dataseed.binance.org/'\n          // \"https://data-seed-prebsc-1-s1.binance.org:8545/\"\n        )\n      );\n      reject(false);\n    }\n  });\n};\n\nconst walletConnectInit = () => {\n  // Check if WalleConnect has been conected by the website\n  return new Promise((resolve, reject) => {\n    if (!walletConnectProvider.connector.connected) {\n      metamaskConnectInit();\n      reject(false);\n    } else {\n      // Use WalletConnect provider.\n      walletConnectProvider.enable();\n      web3 = new Web3(walletConnectProvider);\n      resolve(true);\n    }\n  });\n};\n\nconst walletConnectModalInit = () => {\n  return new Promise((resolve, reject) => {\n    localStorage.setItem('walletConnect', 1);\n    walletConnectProvider.enable();\n    web3 = new Web3(walletConnectProvider);\n    // Wallet Connect Provider Events\n    walletConnectProvider.connector.on('display_uri', (err, payload) => {\n      const uri = payload.params[0];\n      WalletConnectQRCodeModal.open(uri);\n    });\n    walletConnectProvider.on('connect', () => {\n      WalletConnectQRCodeModal.close(); // close the QR scanner modal\n    });\n    walletConnectProvider.on('disconnect', (code, reason) => {\n      // console.log('wallet connect disconnected', code, reason);\n      localStorage.clear();\n    });\n    resolve(true);\n  });\n};\n\nif (!web3) {\n  if (Number(localStorage.getItem('walletConnect')) > 0) {\n    walletConnectInit();\n  } else metamaskConnectInit();\n}\n\nexport {\n  web3,\n  walletConnectProvider,\n  walletConnectInit,\n  metamaskConnectInit,\n  walletConnectModalInit,\n};\n","import { services } from \"../../services\";\r\nlet networkId = 1;\r\nasync function fetchNetworkId() {\r\n  networkId = await services.getNetworkId();\r\n}\r\nfetchNetworkId();\r\n\r\nfunction getContractAddresses() {\r\n  if (networkId === \"0x4\" || +networkId === 4)\r\n    return {\r\n      token: \"0x7862A31a1a1184882CEe3Aec91Bcc93B0512D09F\",\r\n      nftContractAddress: \"0x932a362d89b60FE93e5d84E009E2C956578Ab536\",\r\n      escrowContractAddres: \"0xf8faB097B5ecFAe11f5257F4fAfF9415bFe25514\",\r\n    };\r\n  else if (+networkId === 1 || networkId === \"0x1\")\r\n    return {\r\n      token: \"0x7862A31a1a1184882CEe3Aec91Bcc93B0512D09F\",\r\n      nftContractAddress: \"0x932a362d89b60FE93e5d84E009E2C956578Ab536\",\r\n      escrowContractAddres: \"0xf8faB097B5ecFAe11f5257F4fAfF9415bFe25514\",\r\n    };\r\n  else\r\n    return {\r\n      token: \"0x7862A31a1a1184882CEe3Aec91Bcc93B0512D09F\",\r\n      nftContractAddress: \"0x932a362d89b60FE93e5d84E009E2C956578Ab536\",\r\n      escrowContractAddres: \"0xf8faB097B5ecFAe11f5257F4fAfF9415bFe25514\",\r\n    };\r\n}\r\nexport default getContractAddresses;\r\n","import axios from \"axios\";\n// staging server\nexport default axios.create({\n  baseURL: \"http://api.3.67.57.47.nip.io/api/v1\",\n});\n\n// // Local\n// export const server_url = \"http://127.0.0.1:4000/\";\n\n// aws s3 bucket confiurations\nexport const awsRegion = \"eu-central-1\";\nexport const awsIdentityPoolId =\n  \"eu-central-1:949b9487-ed35-4eb3-a2d3-1866e6ad890b\";\nexport const awsBucket = \"avangrat-development\";\n\n// set expiry time for the localstorage/cookie data\nexport const expiryTime = 2; // 2 hours\n\n// Instragram config\nexport const client_id = \"4418122684888051\";\nexport const redirect_url = \"http://api.3.67.57.47.nip.io/user/edit-profile/\";\n"],"sourceRoot":""}